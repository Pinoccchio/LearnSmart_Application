import 'dart:math';
import '../models/study_analytics_models.dart';
import '../models/active_recall_models.dart';
import '../models/course_models.dart';
import '../services/supabase_service.dart';
import '../services/gemini_ai_service.dart';

class StudyAnalyticsService {
  late final GeminiAIService _aiService;
  
  StudyAnalyticsService() {
    _aiService = GeminiAIService();
  }

  /// Generate comprehensive analytics for a completed study session
  Future<StudySessionAnalytics> generateSessionAnalytics({
    required String sessionId,
    required String userId,
    required String moduleId,
    required List<ActiveRecallFlashcard> flashcards,
    required List<ActiveRecallAttempt> attempts,
    required Course course,
    required Module module,
  }) async {
    try {
      print('üìä [ANALYTICS] Starting comprehensive analysis for session: $sessionId');
      
      // Split attempts into pre and post study
      final preStudyAttempts = attempts.where((a) => a.isPreStudy).toList();
      final postStudyAttempts = attempts.where((a) => !a.isPreStudy).toList();
      
      print('üìä [ANALYTICS] Pre-study attempts: ${preStudyAttempts.length}, Post-study: ${postStudyAttempts.length}');

      // Calculate descriptive analytics
      final performanceMetrics = _calculatePerformanceMetrics(
        flashcards, preStudyAttempts, postStudyAttempts, module.materials
      );
      
      final learningPatterns = _analyzeLearningPatterns(
        flashcards, preStudyAttempts, postStudyAttempts
      );
      
      final behaviorAnalysis = _analyzeBehavior(attempts, flashcards);
      
      final cognitiveAnalysis = _analyzeCognition(attempts, flashcards);
      
      // Generate AI-powered insights and recommendations
      final aiResults = await _generateAIInsights(
        performanceMetrics, learningPatterns, behaviorAnalysis, 
        cognitiveAnalysis, course, module
      );
      
      // Create the analytics object (let database generate UUID)
      final analytics = StudySessionAnalytics(
        id: '', // Will be generated by database
        sessionId: sessionId,
        userId: userId,
        moduleId: moduleId,
        analyzedAt: DateTime.now(),
        performanceMetrics: performanceMetrics,
        learningPatterns: learningPatterns,
        behaviorAnalysis: behaviorAnalysis,
        cognitiveAnalysis: cognitiveAnalysis,
        recommendations: aiResults['recommendations'] as List<PersonalizedRecommendation>,
        insights: aiResults['insights'] as List<AnalyticsInsight>,
        suggestedStudyPlan: aiResults['studyPlan'] as StudyPlan,
      );
      
      // Save to database (but continue even if it fails)
      await _saveAnalyticsToDatabase(analytics);
      
      print('‚úÖ [ANALYTICS] Analytics generation completed successfully');
      return analytics;
      
    } catch (e) {
      print('‚ùå [ANALYTICS] Error generating session analytics: $e');
      
      // Return basic analytics if full analysis fails
      return _generateFallbackAnalytics(sessionId, userId, moduleId, flashcards, attempts);
    }
  }

  /// Calculate performance metrics from session data
  PerformanceMetrics _calculatePerformanceMetrics(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
    List<CourseMaterial> materials,
  ) {
    // Basic accuracy calculations
    final preCorrect = preStudyAttempts.where((a) => a.isCorrect).length;
    final postCorrect = postStudyAttempts.where((a) => a.isCorrect).length;
    
    final preAccuracy = preStudyAttempts.isNotEmpty ? (preCorrect / preStudyAttempts.length) * 100 : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty ? (postCorrect / postStudyAttempts.length) * 100 : 0.0;
    final improvement = postAccuracy - preAccuracy;
    
    // Average response time calculation
    final allAttempts = [...preStudyAttempts, ...postStudyAttempts];
    final avgResponseTime = allAttempts.isNotEmpty 
        ? allAttempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / allAttempts.length 
        : 0.0;
    
    // Performance by difficulty
    final difficultyPerformance = _calculateDifficultyPerformance(flashcards, postStudyAttempts);
    
    // Material-specific performance
    final materialPerformance = _calculateMaterialPerformance(flashcards, postStudyAttempts, materials);
    
    // Concept mastery analysis
    final conceptMastery = _calculateConceptMastery(flashcards, postStudyAttempts);
    
    return PerformanceMetrics(
      preStudyAccuracy: preAccuracy,
      postStudyAccuracy: postAccuracy,
      improvementPercentage: improvement,
      averageResponseTime: avgResponseTime,
      accuracyByDifficulty: difficultyPerformance,
      materialPerformance: materialPerformance,
      conceptMastery: conceptMastery,
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(postAccuracy),
    );
  }

  /// Analyze learning patterns
  LearningPatterns _analyzeLearningPatterns(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
  ) {
    final allAttempts = [...preStudyAttempts, ...postStudyAttempts];
    final attemptResults = postStudyAttempts.map((a) => a.isCorrect).toList();
    
    final preAccuracy = preStudyAttempts.isNotEmpty 
        ? (preStudyAttempts.where((a) => a.isCorrect).length / preStudyAttempts.length) * 100 
        : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty 
        ? (postStudyAttempts.where((a) => a.isCorrect).length / postStudyAttempts.length) * 100 
        : 0.0;
    
    final avgResponseTime = allAttempts.isNotEmpty 
        ? allAttempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / allAttempts.length 
        : 0.0;
    
    // Determine learning pattern type
    final patternType = AnalyticsCalculator.determineLearningPattern(
      preAccuracy, postAccuracy, avgResponseTime, attemptResults
    );
    
    // Calculate learning velocity (improvement per question)
    final learningVelocity = flashcards.isNotEmpty ? (postAccuracy - preAccuracy) / flashcards.length : 0.0;
    
    // Identify strong and weak concepts
    final conceptAnalysis = _analyzeConceptStrengths(flashcards, postStudyAttempts);
    
    // Calculate retention rates by question type
    final retentionRates = _calculateRetentionRates(flashcards, preStudyAttempts, postStudyAttempts);
    
    // Analyze temporal patterns (placeholder - would need historical data)
    final temporalPatterns = <TimeBasedPattern>[
      TimeBasedPattern(
        timeframe: 'current_session',
        performanceScore: postAccuracy,
        pattern: patternType.name,
        observations: ['This session performance pattern'],
      ),
    ];
    
    return LearningPatterns(
      patternType: patternType,
      learningVelocity: learningVelocity,
      strongConcepts: conceptAnalysis['strong']!,
      weakConcepts: conceptAnalysis['weak']!,
      retentionRates: retentionRates,
      temporalPatterns: temporalPatterns,
    );
  }

  /// Analyze study behavior patterns
  BehaviorAnalysis _analyzeBehavior(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    // Calculate total study time (approximate)
    final totalTime = attempts.fold<int>(0, (sum, attempt) => sum + attempt.responseTimeSeconds);
    
    // Hint usage analysis (placeholder - would need hint usage tracking)
    const hintUsageCount = 0;
    const hintEffectiveness = 0.0;
    
    // Common error types analysis
    final errorTypes = _identifyCommonErrorTypes(attempts, flashcards);
    
    // Question attempt patterns
    final attemptPatterns = _analyzeAttemptPatterns(attempts);
    
    // Persistence score (based on response times for incorrect answers)
    final persistenceScore = _calculatePersistenceScore(attempts);
    
    // Engagement level (based on response times and accuracy patterns)
    final engagementLevel = _calculateEngagementLevel(attempts);
    
    return BehaviorAnalysis(
      totalStudyTime: Duration(seconds: totalTime),
      hintUsageCount: hintUsageCount,
      hintEffectiveness: hintEffectiveness,
      commonErrorTypes: errorTypes,
      questionAttemptPatterns: attemptPatterns,
      persistenceScore: persistenceScore,
      engagementLevel: engagementLevel,
    );
  }

  /// Analyze cognitive patterns
  CognitiveAnalysis _analyzeCognition(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    // Cognitive load score (based on response time variance)
    final cognitiveLoadScore = _calculateCognitiveLoad(attempts);
    
    // Memory retention by flashcard type
    final memoryRetentionByType = _calculateMemoryRetentionByType(flashcards, attempts);
    
    // Processing speed (inverse of average response time)
    final avgResponseTime = attempts.isNotEmpty 
        ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length 
        : 30.0;
    final processingSpeed = avgResponseTime > 0 ? (60 / avgResponseTime) * 100 : 0.0;
    
    // Cognitive strengths and weaknesses
    final cognitiveProfile = _analyzeCognitiveProfile(attempts, flashcards);
    
    // Attention span (based on performance degradation over time)
    final attentionSpan = _calculateAttentionSpan(attempts);
    
    return CognitiveAnalysis(
      cognitiveLoadScore: cognitiveLoadScore,
      memoryRetentionByType: memoryRetentionByType,
      processingSpeed: processingSpeed,
      cognitiveStrengths: cognitiveProfile['strengths']!,
      cognitiveWeaknesses: cognitiveProfile['weaknesses']!,
      attentionSpan: attentionSpan,
    );
  }

  /// Generate AI-powered insights and recommendations
  Future<Map<String, dynamic>> _generateAIInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
    Course course,
    Module module,
  ) async {
    try {
      print('ü§ñ [AI INSIGHTS] Generating AI-powered recommendations and insights...');
      
      // Create comprehensive data summary for AI
      final analyticsData = {
        'course': course.title,
        'module': module.title,
        'performance': {
          'pre_study_accuracy': performance.preStudyAccuracy,
          'post_study_accuracy': performance.postStudyAccuracy,
          'improvement': performance.improvementPercentage,
          'avg_response_time': performance.averageResponseTime,
          'overall_level': performance.overallLevel.name,
        },
        'learning_patterns': {
          'pattern_type': patterns.patternType.name,
          'learning_velocity': patterns.learningVelocity,
          'strong_concepts': patterns.strongConcepts,
          'weak_concepts': patterns.weakConcepts,
        },
        'behavior': {
          'total_study_minutes': behavior.totalStudyTime.inMinutes,
          'persistence_score': behavior.persistenceScore,
          'engagement_level': behavior.engagementLevel,
          'common_errors': behavior.commonErrorTypes,
        },
        'cognitive': {
          'cognitive_load': cognitive.cognitiveLoadScore,
          'processing_speed': cognitive.processingSpeed,
          'attention_span': cognitive.attentionSpan,
          'strengths': cognitive.cognitiveStrengths,
          'weaknesses': cognitive.cognitiveWeaknesses,
        },
      };
      
      // Generate AI insights using the enhanced Gemini service
      final aiResults = await _aiService.generateStudyAnalyticsInsights(analyticsData);
      
      return aiResults;
      
    } catch (e) {
      print('‚ùå [AI INSIGHTS] Error generating AI insights: $e');
      
      // Return fallback insights
      return _generateFallbackInsights(performance, patterns, behavior, cognitive);
    }
  }

  /// Save analytics to database
  Future<void> _saveAnalyticsToDatabase(StudySessionAnalytics analytics) async {
    try {
      print('üíæ [ANALYTICS] Saving analytics to database...');
      
      final analyticsData = analytics.toJson();
      
      // Remove the empty id field to let database auto-generate UUID
      analyticsData.remove('id');
      
      await SupabaseService.client
          .from('study_session_analytics')
          .insert(analyticsData);
      
      print('‚úÖ [ANALYTICS] Analytics saved to database successfully');
      
    } catch (e) {
      print('‚ùå [ANALYTICS] Error saving analytics to database: $e');
      
      // Provide detailed error information for debugging
      if (e.toString().contains('uuid')) {
        print('üí° [ANALYTICS] UUID format error - check ID generation');
      } else if (e.toString().contains('row-level security')) {
        print('üí° [ANALYTICS] RLS policy error - user may not have insert permission');
      } else if (e.toString().contains('foreign key')) {
        print('üí° [ANALYTICS] Foreign key constraint error - check session/user/module IDs');
      }
      
      // Don't throw - analytics generation should continue even if saving fails
    }
  }

  // Helper methods for specific calculations

  double _calculateDifficultyPerformance(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    if (attempts.isEmpty || flashcards.isEmpty) return 0.0;
    
    // Group attempts by flashcard difficulty
    final difficultyGroups = <String, List<bool>>{};
    
    for (final attempt in attempts) {
      final flashcard = flashcards.firstWhere(
        (f) => f.id == attempt.flashcardId,
        orElse: () => flashcards.first,
      );
      
      final difficulty = flashcard.difficulty.name;
      difficultyGroups[difficulty] ??= [];
      difficultyGroups[difficulty]!.add(attempt.isCorrect);
    }
    
    // Calculate weighted accuracy across difficulties
    double totalWeightedScore = 0.0;
    double totalWeight = 0.0;
    
    for (final entry in difficultyGroups.entries) {
      final accuracy = entry.value.where((correct) => correct).length / entry.value.length;
      final weight = entry.key == 'hard' ? 3.0 : entry.key == 'medium' ? 2.0 : 1.0;
      totalWeightedScore += accuracy * weight;
      totalWeight += weight;
    }
    
    return totalWeight > 0 ? (totalWeightedScore / totalWeight) * 100 : 0.0;
  }

  Map<String, double> _calculateMaterialPerformance(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
    List<CourseMaterial> materials,
  ) {
    final materialPerformance = <String, double>{};
    
    for (final material in materials) {
      final materialFlashcards = flashcards.where((f) => f.materialId == material.id).toList();
      final materialAttempts = attempts.where((a) => 
        materialFlashcards.any((f) => f.id == a.flashcardId)
      ).toList();
      
      if (materialAttempts.isNotEmpty) {
        final accuracy = materialAttempts.where((a) => a.isCorrect).length / materialAttempts.length;
        materialPerformance[material.title] = accuracy * 100;
      }
    }
    
    return materialPerformance;
  }

  Map<String, double> _calculateConceptMastery(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    // Group flashcards by type as a proxy for concept areas
    final conceptGroups = <String, List<String>>{};
    
    for (final flashcard in flashcards) {
      final concept = flashcard.type.name;
      conceptGroups[concept] ??= [];
      conceptGroups[concept]!.add(flashcard.id);
    }
    
    final conceptMastery = <String, double>{};
    
    for (final entry in conceptGroups.entries) {
      final conceptAttempts = attempts.where((a) => entry.value.contains(a.flashcardId)).toList();
      if (conceptAttempts.isNotEmpty) {
        final accuracy = conceptAttempts.where((a) => a.isCorrect).length / conceptAttempts.length;
        conceptMastery[entry.key] = accuracy * 100;
      }
    }
    
    return conceptMastery;
  }

  Map<String, List<String>> _analyzeConceptStrengths(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    final conceptPerformance = _calculateConceptMastery(flashcards, attempts);
    
    final strong = <String>[];
    final weak = <String>[];
    
    conceptPerformance.forEach((concept, accuracy) {
      if (accuracy >= 80) {
        strong.add(concept);
      } else if (accuracy < 60) {
        weak.add(concept);
      }
    });
    
    return {'strong': strong, 'weak': weak};
  }

  Map<String, double> _calculateRetentionRates(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
  ) {
    final retentionRates = <String, double>{};
    
    for (final flashcard in flashcards) {
      final preAttempt = preStudyAttempts.where((a) => a.flashcardId == flashcard.id).firstOrNull;
      final postAttempt = postStudyAttempts.where((a) => a.flashcardId == flashcard.id).firstOrNull;
      
      if (preAttempt != null && postAttempt != null) {
        // Calculate retention as improvement or maintenance of correct answers
        final retention = postAttempt.isCorrect ? 1.0 : (preAttempt.isCorrect ? 0.0 : 0.5);
        retentionRates[flashcard.type.name] = 
            (retentionRates[flashcard.type.name] ?? 0.0) + retention;
      }
    }
    
    // Average the retention rates
    final typeCounts = <String, int>{};
    for (final flashcard in flashcards) {
      typeCounts[flashcard.type.name] = (typeCounts[flashcard.type.name] ?? 0) + 1;
    }
    
    retentionRates.forEach((type, totalRetention) {
      final count = typeCounts[type] ?? 1;
      retentionRates[type] = (totalRetention / count) * 100;
    });
    
    return retentionRates;
  }

  List<String> _identifyCommonErrorTypes(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    final errorTypes = <String>[];
    final incorrectAttempts = attempts.where((a) => !a.isCorrect).toList();
    
    if (incorrectAttempts.length > attempts.length * 0.3) {
      errorTypes.add('High error rate');
    }
    
    final slowAttempts = attempts.where((a) => a.responseTimeSeconds > 30).toList();
    if (slowAttempts.length > attempts.length * 0.4) {
      errorTypes.add('Slow processing');
    }
    
    // Analyze by question type
    final typeErrors = <String, int>{};
    for (final attempt in incorrectAttempts) {
      final flashcard = flashcards.firstWhere(
        (f) => f.id == attempt.flashcardId,
        orElse: () => flashcards.first,
      );
      typeErrors[flashcard.type.name] = (typeErrors[flashcard.type.name] ?? 0) + 1;
    }
    
    typeErrors.forEach((type, count) {
      if (count > incorrectAttempts.length * 0.4) {
        errorTypes.add('Difficulty with $type questions');
      }
    });
    
    return errorTypes.isEmpty ? ['No significant error patterns identified'] : errorTypes;
  }

  Map<String, int> _analyzeAttemptPatterns(List<ActiveRecallAttempt> attempts) {
    return {
      'total_attempts': attempts.length,
      'correct_attempts': attempts.where((a) => a.isCorrect).length,
      'quick_responses': attempts.where((a) => a.responseTimeSeconds < 10).length,
      'slow_responses': attempts.where((a) => a.responseTimeSeconds > 30).length,
    };
  }

  double _calculatePersistenceScore(List<ActiveRecallAttempt> attempts) {
    if (attempts.isEmpty) return 0.0;
    
    // Calculate based on response time consistency and error recovery
    final responseTimes = attempts.map((a) => a.responseTimeSeconds.toDouble()).toList();
    final avgTime = responseTimes.reduce((a, b) => a + b) / responseTimes.length;
    
    final consistency = 1.0 - (_calculateStandardDeviation(responseTimes) / avgTime);
    final errorRecovery = _calculateErrorRecoveryRate(attempts);
    
    return ((consistency + errorRecovery) / 2) * 100;
  }

  double _calculateEngagementLevel(List<ActiveRecallAttempt> attempts) {
    if (attempts.isEmpty) return 0.0;
    
    // High engagement = consistent response times + good accuracy
    final avgResponseTime = attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length;
    final accuracy = attempts.where((a) => a.isCorrect).length / attempts.length;
    
    // Optimal response time is between 10-25 seconds
    final timeScore = avgResponseTime >= 10 && avgResponseTime <= 25 ? 1.0 : 
                     avgResponseTime < 5 ? 0.3 : // Too fast might indicate guessing
                     avgResponseTime > 45 ? 0.5 : 0.8; // Too slow might indicate disengagement
    
    return ((timeScore + accuracy) / 2) * 100;
  }

  double _calculateCognitiveLoad(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 2) return 0.0;
    
    final responseTimes = attempts.map((a) => a.responseTimeSeconds.toDouble()).toList();
    final variance = _calculateVariance(responseTimes);
    
    // Higher variance suggests higher cognitive load
    return min(100.0, (variance / 100) * 100);
  }

  Map<String, double> _calculateMemoryRetentionByType(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    final retentionByType = <String, double>{};
    
    for (final type in FlashcardType.values) {
      final typeFlashcards = flashcards.where((f) => f.type == type).toList();
      final typeAttempts = attempts.where((a) => 
        typeFlashcards.any((f) => f.id == a.flashcardId)
      ).toList();
      
      if (typeAttempts.isNotEmpty) {
        final accuracy = typeAttempts.where((a) => a.isCorrect).length / typeAttempts.length;
        retentionByType[type.name] = accuracy * 100;
      }
    }
    
    return retentionByType;
  }

  Map<String, List<String>> _analyzeCognitiveProfile(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    final strengths = <String>[];
    final weaknesses = <String>[];
    
    // Analyze processing speed
    final avgResponseTime = attempts.isNotEmpty 
        ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length 
        : 30;
    
    if (avgResponseTime < 15) {
      strengths.add('Fast processing speed');
    } else if (avgResponseTime > 35) {
      weaknesses.add('Slow processing speed');
    }
    
    // Analyze consistency
    final accuracy = attempts.isNotEmpty 
        ? attempts.where((a) => a.isCorrect).length / attempts.length 
        : 0.0;
    
    if (accuracy > 0.8) {
      strengths.add('High accuracy');
    } else if (accuracy < 0.5) {
      weaknesses.add('Low accuracy');
    }
    
    // Analyze memory types based on flashcard performance
    final memoryRetention = _calculateMemoryRetentionByType(flashcards, attempts);
    memoryRetention.forEach((type, retention) {
      if (retention > 80) {
        strengths.add('Strong $type memory');
      } else if (retention < 50) {
        weaknesses.add('Weak $type memory');
      }
    });
    
    return {
      'strengths': strengths.isEmpty ? ['Consistent performance'] : strengths,
      'weaknesses': weaknesses.isEmpty ? ['No significant weaknesses identified'] : weaknesses,
    };
  }

  double _calculateAttentionSpan(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 3) return 100.0;
    
    // Analyze performance degradation over time
    final firstHalf = attempts.take(attempts.length ~/ 2).toList();
    final secondHalf = attempts.skip(attempts.length ~/ 2).toList();
    
    final firstHalfAccuracy = firstHalf.where((a) => a.isCorrect).length / firstHalf.length;
    final secondHalfAccuracy = secondHalf.where((a) => a.isCorrect).length / secondHalf.length;
    
    // If performance remains stable, attention span is good
    final degradation = firstHalfAccuracy - secondHalfAccuracy;
    return max(0.0, min(100.0, (1.0 - degradation.abs()) * 100));
  }

  // Statistical helper methods
  double _calculateVariance(List<double> values) {
    if (values.isEmpty) return 0.0;
    
    final mean = values.reduce((a, b) => a + b) / values.length;
    final squaredDiffs = values.map((value) => pow(value - mean, 2)).toList();
    return squaredDiffs.reduce((a, b) => a + b) / values.length;
  }

  double _calculateStandardDeviation(List<double> values) {
    return sqrt(_calculateVariance(values));
  }

  double _calculateErrorRecoveryRate(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 2) return 1.0;
    
    int recoveries = 0;
    int errorOpportunities = 0;
    
    for (int i = 1; i < attempts.length; i++) {
      if (!attempts[i - 1].isCorrect) {
        errorOpportunities++;
        if (attempts[i].isCorrect) {
          recoveries++;
        }
      }
    }
    
    return errorOpportunities > 0 ? recoveries / errorOpportunities : 1.0;
  }

  /// Generate fallback insights when AI generation fails
  Map<String, dynamic> _generateFallbackInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
  ) {
    final recommendations = <PersonalizedRecommendation>[
      PersonalizedRecommendation(
        id: 'fallback_rec_1',
        type: RecommendationType.studyTiming,
        title: 'Optimize Study Schedule',
        description: 'Based on your performance patterns, consider adjusting your study timing.',
        actionableAdvice: performance.improvementPercentage > 20 
            ? 'Continue with your current study schedule - it\'s working well!'
            : 'Try studying during your peak focus hours for better retention.',
        priority: 1,
        confidenceScore: 0.7,
        reasons: ['Performance analysis', 'Timing patterns'],
      ),
    ];
    
    final insights = <AnalyticsInsight>[
      AnalyticsInsight(
        id: 'fallback_insight_1',
        category: InsightCategory.performance,
        title: 'Session Performance Summary',
        insight: 'You showed a ${performance.improvementPercentage.toStringAsFixed(1)}% improvement from pre-study to post-study.',
        significance: 0.8,
        supportingData: ['Pre-study: ${performance.preStudyAccuracy.toStringAsFixed(1)}%', 'Post-study: ${performance.postStudyAccuracy.toStringAsFixed(1)}%'],
      ),
    ];
    
    final studyPlan = StudyPlan(
      id: 'fallback_plan_1',
      activities: [
        StudyActivity(
          type: 'review',
          description: 'Review weak concept areas',
          duration: const Duration(minutes: 30),
          priority: 1,
          materials: patterns.weakConcepts,
        ),
      ],
      estimatedDuration: const Duration(minutes: 30),
      focusAreas: {'weak_concepts': patterns.weakConcepts.join(', ')},
      objectives: ['Improve weak areas', 'Maintain strong performance'],
    );
    
    return {
      'recommendations': recommendations,
      'insights': insights,
      'studyPlan': studyPlan,
    };
  }

  /// Generate fallback analytics when full analysis fails
  StudySessionAnalytics _generateFallbackAnalytics(
    String sessionId,
    String userId,
    String moduleId,
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    // Basic calculations
    final preStudyAttempts = attempts.where((a) => a.isPreStudy).toList();
    final postStudyAttempts = attempts.where((a) => !a.isPreStudy).toList();
    
    final preAccuracy = preStudyAttempts.isNotEmpty ? (preStudyAttempts.where((a) => a.isCorrect).length / preStudyAttempts.length) * 100 : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty ? (postStudyAttempts.where((a) => a.isCorrect).length / postStudyAttempts.length) * 100 : 0.0;
    final improvementPercentage = postAccuracy - preAccuracy;
    final averageResponseTime = attempts.isNotEmpty ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length : 0.0;
    
    final basicPerformance = PerformanceMetrics(
      preStudyAccuracy: preAccuracy,
      postStudyAccuracy: postAccuracy,
      improvementPercentage: improvementPercentage,
      averageResponseTime: averageResponseTime,
      accuracyByDifficulty: 0.0,
      materialPerformance: {},
      conceptMastery: {},
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(postAccuracy),
    );
    
    return StudySessionAnalytics(
      id: '', // Database will generate UUID
      sessionId: sessionId,
      userId: userId,
      moduleId: moduleId,
      analyzedAt: DateTime.now(),
      performanceMetrics: basicPerformance,
      learningPatterns: LearningPatterns(
        patternType: LearningPatternType.steadyProgression,
        learningVelocity: 0.0,
        strongConcepts: [],
        weakConcepts: [],
        retentionRates: {},
        temporalPatterns: [],
      ),
      behaviorAnalysis: BehaviorAnalysis(
        totalStudyTime: Duration(seconds: attempts.fold<int>(0, (sum, a) => sum + a.responseTimeSeconds)),
        hintUsageCount: 0,
        hintEffectiveness: 0.0,
        commonErrorTypes: [],
        questionAttemptPatterns: {},
        persistenceScore: 75.0,
        engagementLevel: 75.0,
      ),
      cognitiveAnalysis: CognitiveAnalysis(
        cognitiveLoadScore: 50.0,
        memoryRetentionByType: {},
        processingSpeed: 50.0,
        cognitiveStrengths: [],
        cognitiveWeaknesses: [],
        attentionSpan: 75.0,
      ),
      recommendations: [],
      insights: [],
      suggestedStudyPlan: StudyPlan(
        id: 'fallback_plan',
        activities: [],
        estimatedDuration: const Duration(minutes: 30),
        focusAreas: {},
        objectives: [],
      ),
    );
  }
}