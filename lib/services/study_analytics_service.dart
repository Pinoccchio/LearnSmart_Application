import 'dart:math';
import '../models/study_analytics_models.dart';
import '../models/active_recall_models.dart';
import '../models/pomodoro_models.dart';
import '../models/course_models.dart';
import '../services/supabase_service.dart';
import '../services/gemini_ai_service.dart';

class StudyAnalyticsService {
  late final GeminiAIService _aiService;
  
  StudyAnalyticsService() {
    _aiService = GeminiAIService();
  }

  /// Generate comprehensive analytics for a completed study session
  Future<StudySessionAnalytics> generateSessionAnalytics({
    required String sessionId,
    required String userId,
    required String moduleId,
    required List<ActiveRecallFlashcard> flashcards,
    required List<ActiveRecallAttempt> attempts,
    required Course course,
    required Module module,
  }) async {
    try {
      print('üìä [ANALYTICS] Starting comprehensive analysis for session: $sessionId');
      
      // Split attempts into pre and post study
      final preStudyAttempts = attempts.where((a) => a.isPreStudy).toList();
      final postStudyAttempts = attempts.where((a) => !a.isPreStudy).toList();
      
      print('üìä [ANALYTICS] Pre-study attempts: ${preStudyAttempts.length}, Post-study: ${postStudyAttempts.length}');

      // Calculate descriptive analytics
      final performanceMetrics = _calculatePerformanceMetrics(
        flashcards, preStudyAttempts, postStudyAttempts, module.materials
      );
      
      final learningPatterns = _analyzeLearningPatterns(
        flashcards, preStudyAttempts, postStudyAttempts
      );
      
      final behaviorAnalysis = _analyzeBehavior(attempts, flashcards);
      
      final cognitiveAnalysis = _analyzeCognition(attempts, flashcards);
      
      // Generate AI-powered insights and recommendations
      final aiResults = await _generateAIInsights(
        performanceMetrics, learningPatterns, behaviorAnalysis, 
        cognitiveAnalysis, course, module
      );
      
      // Create the analytics object (let database generate UUID)
      final analytics = StudySessionAnalytics(
        id: '', // Will be generated by database
        sessionId: sessionId,
        userId: userId,
        moduleId: moduleId,
        analyzedAt: DateTime.now(),
        performanceMetrics: performanceMetrics,
        learningPatterns: learningPatterns,
        behaviorAnalysis: behaviorAnalysis,
        cognitiveAnalysis: cognitiveAnalysis,
        recommendations: aiResults['recommendations'] as List<PersonalizedRecommendation>,
        insights: aiResults['insights'] as List<AnalyticsInsight>,
        suggestedStudyPlan: aiResults['studyPlan'] as StudyPlan,
      );
      
      // Save to database (but continue even if it fails)
      await _saveAnalyticsToDatabase(analytics, sessionType: 'active_recall');
      
      print('‚úÖ [ANALYTICS] Analytics generation completed successfully');
      return analytics;
      
    } catch (e) {
      print('‚ùå [ANALYTICS] Error generating session analytics: $e');
      
      // Return basic analytics if full analysis fails
      return _generateFallbackAnalytics(sessionId, userId, moduleId, flashcards, attempts);
    }
  }

  /// Calculate performance metrics from session data
  PerformanceMetrics _calculatePerformanceMetrics(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
    List<CourseMaterial> materials,
  ) {
    // Basic accuracy calculations
    final preCorrect = preStudyAttempts.where((a) => a.isCorrect).length;
    final postCorrect = postStudyAttempts.where((a) => a.isCorrect).length;
    
    final preAccuracy = preStudyAttempts.isNotEmpty ? (preCorrect / preStudyAttempts.length) * 100 : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty ? (postCorrect / postStudyAttempts.length) * 100 : 0.0;
    final improvement = postAccuracy - preAccuracy;
    
    // Average response time calculation
    final allAttempts = [...preStudyAttempts, ...postStudyAttempts];
    final avgResponseTime = allAttempts.isNotEmpty 
        ? allAttempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / allAttempts.length 
        : 0.0;
    
    // Performance by difficulty
    final difficultyPerformance = _calculateDifficultyPerformance(flashcards, postStudyAttempts);
    
    // Material-specific performance
    final materialPerformance = _calculateMaterialPerformance(flashcards, postStudyAttempts, materials);
    
    // Concept mastery analysis
    final conceptMastery = _calculateConceptMastery(flashcards, postStudyAttempts);
    
    return PerformanceMetrics(
      preStudyAccuracy: preAccuracy,
      postStudyAccuracy: postAccuracy,
      improvementPercentage: improvement,
      averageResponseTime: avgResponseTime,
      accuracyByDifficulty: difficultyPerformance,
      materialPerformance: materialPerformance,
      conceptMastery: conceptMastery,
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(postAccuracy),
    );
  }

  /// Analyze learning patterns
  LearningPatterns _analyzeLearningPatterns(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
  ) {
    final allAttempts = [...preStudyAttempts, ...postStudyAttempts];
    final attemptResults = postStudyAttempts.map((a) => a.isCorrect).toList();
    
    final preAccuracy = preStudyAttempts.isNotEmpty 
        ? (preStudyAttempts.where((a) => a.isCorrect).length / preStudyAttempts.length) * 100 
        : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty 
        ? (postStudyAttempts.where((a) => a.isCorrect).length / postStudyAttempts.length) * 100 
        : 0.0;
    
    final avgResponseTime = allAttempts.isNotEmpty 
        ? allAttempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / allAttempts.length 
        : 0.0;
    
    // Determine learning pattern type
    final patternType = AnalyticsCalculator.determineLearningPattern(
      preAccuracy, postAccuracy, avgResponseTime, attemptResults
    );
    
    // Calculate learning velocity (improvement per question)
    final learningVelocity = flashcards.isNotEmpty ? (postAccuracy - preAccuracy) / flashcards.length : 0.0;
    
    // Identify strong and weak concepts
    final conceptAnalysis = _analyzeConceptStrengths(flashcards, postStudyAttempts);
    
    // Calculate retention rates by question type
    final retentionRates = _calculateRetentionRates(flashcards, preStudyAttempts, postStudyAttempts);
    
    // Analyze temporal patterns (placeholder - would need historical data)
    final temporalPatterns = <TimeBasedPattern>[
      TimeBasedPattern(
        timeframe: 'current_session',
        performanceScore: postAccuracy,
        pattern: patternType.name,
        observations: ['This session performance pattern'],
      ),
    ];
    
    return LearningPatterns(
      patternType: patternType,
      learningVelocity: learningVelocity,
      strongConcepts: conceptAnalysis['strong']!,
      weakConcepts: conceptAnalysis['weak']!,
      retentionRates: retentionRates,
      temporalPatterns: temporalPatterns,
    );
  }

  /// Analyze study behavior patterns
  BehaviorAnalysis _analyzeBehavior(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    // Calculate total study time (approximate)
    final totalTime = attempts.fold<int>(0, (sum, attempt) => sum + attempt.responseTimeSeconds);
    
    // Hint usage analysis (placeholder - would need hint usage tracking)
    const hintUsageCount = 0;
    const hintEffectiveness = 0.0;
    
    // Common error types analysis
    final errorTypes = _identifyCommonErrorTypes(attempts, flashcards);
    
    // Question attempt patterns
    final attemptPatterns = _analyzeAttemptPatterns(attempts);
    
    // Persistence score (based on response times for incorrect answers)
    final persistenceScore = _calculatePersistenceScore(attempts);
    
    // Engagement level (based on response times and accuracy patterns)
    final engagementLevel = _calculateEngagementLevel(attempts);
    
    return BehaviorAnalysis(
      totalStudyTime: Duration(seconds: totalTime),
      hintUsageCount: hintUsageCount,
      hintEffectiveness: hintEffectiveness,
      commonErrorTypes: errorTypes,
      questionAttemptPatterns: attemptPatterns,
      persistenceScore: persistenceScore,
      engagementLevel: engagementLevel,
    );
  }

  /// Analyze cognitive patterns
  CognitiveAnalysis _analyzeCognition(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    // Cognitive load score (based on response time variance)
    final cognitiveLoadScore = _calculateCognitiveLoad(attempts);
    
    // Memory retention by flashcard type
    final memoryRetentionByType = _calculateMemoryRetentionByType(flashcards, attempts);
    
    // Processing speed (inverse of average response time)
    final avgResponseTime = attempts.isNotEmpty 
        ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length 
        : 30.0;
    final processingSpeed = avgResponseTime > 0 ? (60 / avgResponseTime) * 100 : 0.0;
    
    // Cognitive strengths and weaknesses
    final cognitiveProfile = _analyzeCognitiveProfile(attempts, flashcards);
    
    // Attention span (based on performance degradation over time)
    final attentionSpan = _calculateAttentionSpan(attempts);
    
    return CognitiveAnalysis(
      cognitiveLoadScore: cognitiveLoadScore,
      memoryRetentionByType: memoryRetentionByType,
      processingSpeed: processingSpeed,
      cognitiveStrengths: cognitiveProfile['strengths']!,
      cognitiveWeaknesses: cognitiveProfile['weaknesses']!,
      attentionSpan: attentionSpan,
    );
  }

  /// Generate AI-powered insights and recommendations
  Future<Map<String, dynamic>> _generateAIInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
    Course course,
    Module module,
  ) async {
    try {
      print('ü§ñ [AI INSIGHTS] Generating AI-powered recommendations and insights...');
      
      // Create comprehensive data summary for AI
      final analyticsData = {
        'course': course.title,
        'module': module.title,
        'performance': {
          'pre_study_accuracy': performance.preStudyAccuracy,
          'post_study_accuracy': performance.postStudyAccuracy,
          'improvement': performance.improvementPercentage,
          'avg_response_time': performance.averageResponseTime,
          'overall_level': performance.overallLevel.name,
        },
        'learning_patterns': {
          'pattern_type': patterns.patternType.name,
          'learning_velocity': patterns.learningVelocity,
          'strong_concepts': patterns.strongConcepts,
          'weak_concepts': patterns.weakConcepts,
        },
        'behavior': {
          'total_study_minutes': behavior.totalStudyTime.inMinutes,
          'persistence_score': behavior.persistenceScore,
          'engagement_level': behavior.engagementLevel,
          'common_errors': behavior.commonErrorTypes,
        },
        'cognitive': {
          'cognitive_load': cognitive.cognitiveLoadScore,
          'processing_speed': cognitive.processingSpeed,
          'attention_span': cognitive.attentionSpan,
          'strengths': cognitive.cognitiveStrengths,
          'weaknesses': cognitive.cognitiveWeaknesses,
        },
      };
      
      // Generate AI insights using the enhanced Gemini service
      final aiResults = await _aiService.generateStudyAnalyticsInsights(analyticsData);
      
      return aiResults;
      
    } catch (e) {
      print('‚ùå [AI INSIGHTS] Error generating AI insights: $e');
      
      // Return fallback insights
      return _generateFallbackInsights(performance, patterns, behavior, cognitive);
    }
  }

  /// Save analytics to database with session type
  Future<void> _saveAnalyticsToDatabase(StudySessionAnalytics analytics, {String sessionType = 'active_recall'}) async {
    try {
      print('üíæ [ANALYTICS] Saving analytics to database with session type: $sessionType');
      
      final analyticsData = analytics.toJson();
      
      // Remove the empty id field to let database auto-generate UUID
      analyticsData.remove('id');
      
      // Add session_type to the data
      analyticsData['session_type'] = sessionType;
      
      await SupabaseService.client
          .from('study_session_analytics')
          .insert(analyticsData);
      
      print('‚úÖ [ANALYTICS] Analytics saved to database successfully');
      
    } catch (e) {
      print('‚ùå [ANALYTICS] Error saving analytics to database: $e');
      
      // Provide detailed error information for debugging
      if (e.toString().contains('uuid')) {
        print('üí° [ANALYTICS] UUID format error - check ID generation');
      } else if (e.toString().contains('row-level security')) {
        print('üí° [ANALYTICS] RLS policy error - user may not have insert permission');
      } else if (e.toString().contains('foreign key')) {
        print('üí° [ANALYTICS] Foreign key constraint error - check session/user/module IDs');
      } else if (e.toString().contains('session_type')) {
        print('üí° [ANALYTICS] Session type error - check that session_type is valid');
      }
      
      // Don't throw - analytics generation should continue even if saving fails
    }
  }

  // Helper methods for specific calculations

  double _calculateDifficultyPerformance(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    if (attempts.isEmpty || flashcards.isEmpty) return 0.0;
    
    // Group attempts by flashcard difficulty
    final difficultyGroups = <String, List<bool>>{};
    
    for (final attempt in attempts) {
      final flashcard = flashcards.firstWhere(
        (f) => f.id == attempt.flashcardId,
        orElse: () => flashcards.first,
      );
      
      final difficulty = flashcard.difficulty.name;
      difficultyGroups[difficulty] ??= [];
      difficultyGroups[difficulty]!.add(attempt.isCorrect);
    }
    
    // Calculate weighted accuracy across difficulties
    double totalWeightedScore = 0.0;
    double totalWeight = 0.0;
    
    for (final entry in difficultyGroups.entries) {
      final accuracy = entry.value.where((correct) => correct).length / entry.value.length;
      final weight = entry.key == 'hard' ? 3.0 : entry.key == 'medium' ? 2.0 : 1.0;
      totalWeightedScore += accuracy * weight;
      totalWeight += weight;
    }
    
    return totalWeight > 0 ? (totalWeightedScore / totalWeight) * 100 : 0.0;
  }

  Map<String, double> _calculateMaterialPerformance(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
    List<CourseMaterial> materials,
  ) {
    final materialPerformance = <String, double>{};
    
    for (final material in materials) {
      final materialFlashcards = flashcards.where((f) => f.materialId == material.id).toList();
      final materialAttempts = attempts.where((a) => 
        materialFlashcards.any((f) => f.id == a.flashcardId)
      ).toList();
      
      if (materialAttempts.isNotEmpty) {
        final accuracy = materialAttempts.where((a) => a.isCorrect).length / materialAttempts.length;
        materialPerformance[material.title] = accuracy * 100;
      }
    }
    
    return materialPerformance;
  }

  Map<String, double> _calculateConceptMastery(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    // Group flashcards by type as a proxy for concept areas
    final conceptGroups = <String, List<String>>{};
    
    for (final flashcard in flashcards) {
      final concept = flashcard.type.name;
      conceptGroups[concept] ??= [];
      conceptGroups[concept]!.add(flashcard.id);
    }
    
    final conceptMastery = <String, double>{};
    
    for (final entry in conceptGroups.entries) {
      final conceptAttempts = attempts.where((a) => entry.value.contains(a.flashcardId)).toList();
      if (conceptAttempts.isNotEmpty) {
        final accuracy = conceptAttempts.where((a) => a.isCorrect).length / conceptAttempts.length;
        conceptMastery[entry.key] = accuracy * 100;
      }
    }
    
    return conceptMastery;
  }

  Map<String, List<String>> _analyzeConceptStrengths(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    final conceptPerformance = _calculateConceptMastery(flashcards, attempts);
    
    final strong = <String>[];
    final weak = <String>[];
    
    conceptPerformance.forEach((concept, accuracy) {
      if (accuracy >= 80) {
        strong.add(concept);
      } else if (accuracy < 60) {
        weak.add(concept);
      }
    });
    
    return {'strong': strong, 'weak': weak};
  }

  Map<String, double> _calculateRetentionRates(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> preStudyAttempts,
    List<ActiveRecallAttempt> postStudyAttempts,
  ) {
    final retentionRates = <String, double>{};
    
    for (final flashcard in flashcards) {
      final preAttemptList = preStudyAttempts.where((a) => a.flashcardId == flashcard.id).toList();
      final postAttemptList = postStudyAttempts.where((a) => a.flashcardId == flashcard.id).toList();
      final preAttempt = preAttemptList.isNotEmpty ? preAttemptList.first : null;
      final postAttempt = postAttemptList.isNotEmpty ? postAttemptList.first : null;
      
      if (preAttempt != null && postAttempt != null) {
        // Calculate retention as improvement or maintenance of correct answers
        final retention = postAttempt.isCorrect ? 1.0 : (preAttempt.isCorrect ? 0.0 : 0.5);
        retentionRates[flashcard.type.name] = 
            (retentionRates[flashcard.type.name] ?? 0.0) + retention;
      }
    }
    
    // Average the retention rates
    final typeCounts = <String, int>{};
    for (final flashcard in flashcards) {
      typeCounts[flashcard.type.name] = (typeCounts[flashcard.type.name] ?? 0) + 1;
    }
    
    retentionRates.forEach((type, totalRetention) {
      final count = typeCounts[type] ?? 1;
      retentionRates[type] = (totalRetention / count) * 100;
    });
    
    return retentionRates;
  }

  List<String> _identifyCommonErrorTypes(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    final errorTypes = <String>[];
    final incorrectAttempts = attempts.where((a) => !a.isCorrect).toList();
    
    if (incorrectAttempts.length > attempts.length * 0.3) {
      errorTypes.add('High error rate');
    }
    
    final slowAttempts = attempts.where((a) => a.responseTimeSeconds > 30).toList();
    if (slowAttempts.length > attempts.length * 0.4) {
      errorTypes.add('Slow processing');
    }
    
    // Analyze by question type
    final typeErrors = <String, int>{};
    for (final attempt in incorrectAttempts) {
      final flashcard = flashcards.firstWhere(
        (f) => f.id == attempt.flashcardId,
        orElse: () => flashcards.first,
      );
      typeErrors[flashcard.type.name] = (typeErrors[flashcard.type.name] ?? 0) + 1;
    }
    
    typeErrors.forEach((type, count) {
      if (count > incorrectAttempts.length * 0.4) {
        errorTypes.add('Difficulty with $type questions');
      }
    });
    
    return errorTypes.isEmpty ? ['No significant error patterns identified'] : errorTypes;
  }

  Map<String, int> _analyzeAttemptPatterns(List<ActiveRecallAttempt> attempts) {
    return {
      'total_attempts': attempts.length,
      'correct_attempts': attempts.where((a) => a.isCorrect).length,
      'quick_responses': attempts.where((a) => a.responseTimeSeconds < 10).length,
      'slow_responses': attempts.where((a) => a.responseTimeSeconds > 30).length,
    };
  }

  double _calculatePersistenceScore(List<ActiveRecallAttempt> attempts) {
    if (attempts.isEmpty) return 0.0;
    
    // Calculate based on response time consistency and error recovery
    final responseTimes = attempts.map((a) => a.responseTimeSeconds.toDouble()).toList();
    final avgTime = responseTimes.reduce((a, b) => a + b) / responseTimes.length;
    
    final consistency = 1.0 - (_calculateStandardDeviation(responseTimes) / avgTime);
    final errorRecovery = _calculateErrorRecoveryRate(attempts);
    
    return ((consistency + errorRecovery) / 2) * 100;
  }

  double _calculateEngagementLevel(List<ActiveRecallAttempt> attempts) {
    if (attempts.isEmpty) return 0.0;
    
    // High engagement = consistent response times + good accuracy
    final avgResponseTime = attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length;
    final accuracy = attempts.where((a) => a.isCorrect).length / attempts.length;
    
    // Optimal response time is between 10-25 seconds
    final timeScore = avgResponseTime >= 10 && avgResponseTime <= 25 ? 1.0 : 
                     avgResponseTime < 5 ? 0.3 : // Too fast might indicate guessing
                     avgResponseTime > 45 ? 0.5 : 0.8; // Too slow might indicate disengagement
    
    return ((timeScore + accuracy) / 2) * 100;
  }

  double _calculateCognitiveLoad(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 2) return 0.0;
    
    final responseTimes = attempts.map((a) => a.responseTimeSeconds.toDouble()).toList();
    final variance = _calculateVariance(responseTimes);
    
    // Higher variance suggests higher cognitive load
    return min(100.0, (variance / 100) * 100);
  }

  Map<String, double> _calculateMemoryRetentionByType(
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    final retentionByType = <String, double>{};
    
    for (final type in FlashcardType.values) {
      final typeFlashcards = flashcards.where((f) => f.type == type).toList();
      final typeAttempts = attempts.where((a) => 
        typeFlashcards.any((f) => f.id == a.flashcardId)
      ).toList();
      
      if (typeAttempts.isNotEmpty) {
        final accuracy = typeAttempts.where((a) => a.isCorrect).length / typeAttempts.length;
        retentionByType[type.name] = accuracy * 100;
      }
    }
    
    return retentionByType;
  }

  Map<String, List<String>> _analyzeCognitiveProfile(
    List<ActiveRecallAttempt> attempts,
    List<ActiveRecallFlashcard> flashcards,
  ) {
    final strengths = <String>[];
    final weaknesses = <String>[];
    
    // Analyze processing speed
    final avgResponseTime = attempts.isNotEmpty 
        ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length 
        : 30;
    
    if (avgResponseTime < 15) {
      strengths.add('Fast processing speed');
    } else if (avgResponseTime > 35) {
      weaknesses.add('Slow processing speed');
    }
    
    // Analyze consistency
    final accuracy = attempts.isNotEmpty 
        ? attempts.where((a) => a.isCorrect).length / attempts.length 
        : 0.0;
    
    if (accuracy > 0.8) {
      strengths.add('High accuracy');
    } else if (accuracy < 0.5) {
      weaknesses.add('Low accuracy');
    }
    
    // Analyze memory types based on flashcard performance
    final memoryRetention = _calculateMemoryRetentionByType(flashcards, attempts);
    memoryRetention.forEach((type, retention) {
      if (retention > 80) {
        strengths.add('Strong $type memory');
      } else if (retention < 50) {
        weaknesses.add('Weak $type memory');
      }
    });
    
    return {
      'strengths': strengths.isEmpty ? ['Consistent performance'] : strengths,
      'weaknesses': weaknesses.isEmpty ? ['No significant weaknesses identified'] : weaknesses,
    };
  }

  double _calculateAttentionSpan(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 3) return 100.0;
    
    // Analyze performance degradation over time
    final firstHalf = attempts.take(attempts.length ~/ 2).toList();
    final secondHalf = attempts.skip(attempts.length ~/ 2).toList();
    
    final firstHalfAccuracy = firstHalf.where((a) => a.isCorrect).length / firstHalf.length;
    final secondHalfAccuracy = secondHalf.where((a) => a.isCorrect).length / secondHalf.length;
    
    // If performance remains stable, attention span is good
    final degradation = firstHalfAccuracy - secondHalfAccuracy;
    return max(0.0, min(100.0, (1.0 - degradation.abs()) * 100));
  }

  // Statistical helper methods
  double _calculateVariance(List<double> values) {
    if (values.isEmpty) return 0.0;
    
    final mean = values.reduce((a, b) => a + b) / values.length;
    final squaredDiffs = values.map((value) => pow(value - mean, 2)).toList();
    return squaredDiffs.reduce((a, b) => a + b) / values.length;
  }

  double _calculateStandardDeviation(List<double> values) {
    return sqrt(_calculateVariance(values));
  }

  double _calculateErrorRecoveryRate(List<ActiveRecallAttempt> attempts) {
    if (attempts.length < 2) return 1.0;
    
    int recoveries = 0;
    int errorOpportunities = 0;
    
    for (int i = 1; i < attempts.length; i++) {
      if (!attempts[i - 1].isCorrect) {
        errorOpportunities++;
        if (attempts[i].isCorrect) {
          recoveries++;
        }
      }
    }
    
    return errorOpportunities > 0 ? recoveries / errorOpportunities : 1.0;
  }

  /// Generate fallback insights when AI generation fails
  Map<String, dynamic> _generateFallbackInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
  ) {
    final recommendations = <PersonalizedRecommendation>[
      PersonalizedRecommendation(
        id: 'fallback_rec_1',
        type: RecommendationType.studyTiming,
        title: 'Optimize Study Schedule',
        description: 'Based on your performance patterns, consider adjusting your study timing.',
        actionableAdvice: performance.improvementPercentage > 20 
            ? 'Continue with your current study schedule - it\'s working well!'
            : 'Try studying during your peak focus hours for better retention.',
        priority: 1,
        confidenceScore: 0.7,
        reasons: ['Performance analysis', 'Timing patterns'],
      ),
    ];
    
    final insights = <AnalyticsInsight>[
      AnalyticsInsight(
        id: 'fallback_insight_1',
        category: InsightCategory.performance,
        title: 'Session Performance Summary',
        insight: 'You showed a ${performance.improvementPercentage.toStringAsFixed(1)}% improvement from pre-study to post-study.',
        significance: 0.8,
        supportingData: ['Pre-study: ${performance.preStudyAccuracy.toStringAsFixed(1)}%', 'Post-study: ${performance.postStudyAccuracy.toStringAsFixed(1)}%'],
      ),
    ];
    
    final studyPlan = StudyPlan(
      id: 'fallback_plan_1',
      activities: [
        StudyActivity(
          type: 'review',
          description: 'Review weak concept areas',
          duration: const Duration(minutes: 30),
          priority: 1,
          materials: patterns.weakConcepts,
        ),
      ],
      estimatedDuration: const Duration(minutes: 30),
      focusAreas: {'weak_concepts': patterns.weakConcepts.join(', ')},
      objectives: ['Improve weak areas', 'Maintain strong performance'],
    );
    
    return {
      'recommendations': recommendations,
      'insights': insights,
      'studyPlan': studyPlan,
    };
  }

  /// Generate comprehensive analytics for a completed Pomodoro session
  Future<StudySessionAnalytics> generatePomodoroAnalytics({
    required String sessionId,
    required String userId,
    required String moduleId,
    required PomodoroSession session,
    required List<PomodoroCycle> cycles,
    required List<PomodoroNote> notes,
    required Course course,
    required Module module,
  }) async {
    try {
      print('üìä [POMODORO ANALYTICS] Starting comprehensive analysis for session: $sessionId');
      
      // Calculate descriptive analytics
      final performanceMetrics = _calculatePomodoroPerformanceMetrics(session, cycles, notes);
      
      final learningPatterns = _analyzePomodoroLearningPatterns(session, cycles, notes);
      
      final behaviorAnalysis = _analyzePomodoroBehavior(session, cycles, notes);
      
      final cognitiveAnalysis = _analyzePomodoroCognition(session, cycles, notes);
      
      // Generate AI-powered insights and recommendations
      final aiResults = await _generatePomodoroAIInsights(
        performanceMetrics, learningPatterns, behaviorAnalysis, 
        cognitiveAnalysis, course, module, session, cycles, notes
      );
      
      // Create the analytics object
      final analytics = StudySessionAnalytics(
        id: '', // Will be generated by database
        sessionId: sessionId,
        userId: userId,
        moduleId: moduleId,
        analyzedAt: DateTime.now(),
        performanceMetrics: performanceMetrics,
        learningPatterns: learningPatterns,
        behaviorAnalysis: behaviorAnalysis,
        cognitiveAnalysis: cognitiveAnalysis,
        recommendations: aiResults['recommendations'] as List<PersonalizedRecommendation>,
        insights: aiResults['insights'] as List<AnalyticsInsight>,
        suggestedStudyPlan: aiResults['studyPlan'] as StudyPlan,
      );
      
      // Save to database (but continue even if it fails)
      await _saveAnalyticsToDatabase(analytics, sessionType: 'pomodoro');
      
      print('‚úÖ [POMODORO ANALYTICS] Analytics generation completed successfully');
      return analytics;
      
    } catch (e) {
      print('‚ùå [POMODORO ANALYTICS] Error generating session analytics: $e');
      
      // Return basic analytics if full analysis fails
      return _generateFallbackPomodoroAnalytics(sessionId, userId, moduleId, session, cycles, notes);
    }
  }

  /// Calculate performance metrics from Pomodoro session data
  PerformanceMetrics _calculatePomodoroPerformanceMetrics(
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    // Focus score analysis
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!)
        .toList();
    
    final avgFocusScore = focusScores.isNotEmpty 
        ? focusScores.reduce((a, b) => a + b) / focusScores.length 
        : 0.0;
    
    // Completion rate
    final completedCycles = cycles.where((c) => c.actualDuration >= c.plannedDuration).length;
    final completionRate = cycles.isNotEmpty ? (completedCycles / cycles.length) * 100 : 0.0;
    
    // Calculate improvement based on focus score progression
    final earlyFocusScores = focusScores.take(focusScores.length ~/ 2).toList();
    final lateFocusScores = focusScores.skip(focusScores.length ~/ 2).toList();
    
    final earlyAvg = earlyFocusScores.isNotEmpty ? earlyFocusScores.reduce((a, b) => a + b) / earlyFocusScores.length : avgFocusScore;
    final lateAvg = lateFocusScores.isNotEmpty ? lateFocusScores.reduce((a, b) => a + b) / lateFocusScores.length : avgFocusScore;
    final improvement = lateAvg - earlyAvg;
    
    // Productivity score (based on completion rate and focus scores)
    final productivityScore = ((completionRate + avgFocusScore * 10) / 2);
    
    return PerformanceMetrics(
      preStudyAccuracy: earlyAvg * 10, // Convert to percentage scale
      postStudyAccuracy: lateAvg * 10,
      improvementPercentage: improvement * 10,
      averageResponseTime: session.totalDuration.inMinutes / max(1, cycles.length).toDouble(),
      accuracyByDifficulty: productivityScore,
      materialPerformance: {'Focus Score': avgFocusScore * 10, 'Completion Rate': completionRate},
      conceptMastery: _analyzePomodoroConceptMastery(notes),
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(productivityScore),
    );
  }

  /// Analyze Pomodoro learning patterns
  LearningPatterns _analyzePomodoroLearningPatterns(
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    // Focus progression pattern
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!.toDouble())
        .toList();
    
    // Determine pattern type based on focus progression
    LearningPatternType patternType = LearningPatternType.steadyProgression;
    if (focusScores.length >= 3) {
      final trend = _calculateTrend(focusScores);
      if (trend > 0.5) {
        patternType = LearningPatternType.acceleratedLearning;
      } else if (trend < -0.5) {
        patternType = LearningPatternType.fatiguePattern;
      } else {
        patternType = LearningPatternType.steadyProgression;
      }
    }
    
    // Learning velocity (focus improvement per cycle)
    final learningVelocity = focusScores.length > 1 
        ? (focusScores.last - focusScores.first) / focusScores.length 
        : 0.0;
    
    // Strong and weak concepts from notes
    final conceptAnalysis = _analyzePomodoroNotePatterns(notes);
    
    // Retention based on note types and timing
    final retentionRates = _calculatePomodoroRetentionRates(cycles, notes);
    
    // Temporal patterns
    final temporalPatterns = _analyzePomodoroTemporalPatterns(session, cycles);
    
    return LearningPatterns(
      patternType: patternType,
      learningVelocity: learningVelocity,
      strongConcepts: conceptAnalysis['strong']!,
      weakConcepts: conceptAnalysis['weak']!,
      retentionRates: retentionRates,
      temporalPatterns: temporalPatterns,
    );
  }

  /// Analyze Pomodoro study behavior patterns
  BehaviorAnalysis _analyzePomodoroBehavior(
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    // Total study time
    final totalStudyTime = session.totalDuration;
    
    // Break adherence (how well breaks were taken)
    final breakCycles = cycles.where((c) => 
        c.cycleType == PomodoroCycleType.shortBreak || 
        c.cycleType == PomodoroCycleType.longBreak
    ).toList();
    
    final breakAdherence = breakCycles.isNotEmpty 
        ? breakCycles.where((c) => c.actualDuration >= c.plannedDuration * 0.8).length / breakCycles.length
        : 0.0;
    
    // Focus consistency (variance in focus scores)
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!.toDouble())
        .toList();
    
    // Focus consistency is calculated but not used in current implementation
    // final focusConsistency = focusScores.length > 1 
    //     ? 100 - min(100.0, _calculateStandardDeviation(focusScores) * 10)
    //     : 100.0;
    
    // Note-taking patterns
    final notePatterns = _analyzeNotePatterns(notes, cycles);
    
    // Error types (based on low focus scores and incomplete cycles)
    final errorTypes = <String>[];
    final lowFocusCycles = cycles.where((c) => c.focusScore != null && c.focusScore! <= 3).length;
    final incompleteCycles = cycles.where((c) => c.actualDuration < c.plannedDuration * 0.8).length;
    
    if (lowFocusCycles > cycles.length * 0.3) {
      errorTypes.add('Frequent focus challenges');
    }
    if (incompleteCycles > cycles.length * 0.2) {
      errorTypes.add('Difficulty completing cycles');
    }
    if (breakAdherence < 0.5) {
      errorTypes.add('Inadequate break management');
    }
    
    // Persistence based on cycle completion despite difficulties
    final persistenceScore = cycles.isNotEmpty 
        ? (cycles.where((c) => c.isCompleted).length / cycles.length) * 100
        : 0.0;
    
    // Engagement level based on note-taking and focus scores
    final avgFocus = focusScores.isNotEmpty ? focusScores.reduce((a, b) => a + b) / focusScores.length : 5.0;
    final noteEngagement = notes.isNotEmpty ? min(100.0, notes.length * 10) : 0.0;
    final engagementLevel = ((avgFocus * 10 + noteEngagement) / 2);
    
    return BehaviorAnalysis(
      totalStudyTime: totalStudyTime,
      hintUsageCount: notes.where((n) => n.noteType == PomodoroNoteType.reflection).length,
      hintEffectiveness: breakAdherence,
      commonErrorTypes: errorTypes.isEmpty ? ['No significant behavioral issues'] : errorTypes,
      questionAttemptPatterns: notePatterns,
      persistenceScore: persistenceScore,
      engagementLevel: engagementLevel,
    );
  }

  /// Analyze Pomodoro cognitive patterns
  CognitiveAnalysis _analyzePomodoroCognition(
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    // Cognitive load based on focus score variance and cycle completion
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!.toDouble())
        .toList();
    
    final cognitiveLoadScore = focusScores.length > 1 
        ? min(100.0, _calculateVariance(focusScores) * 20)
        : 50.0;
    
    // Processing speed based on cycle efficiency
    final workCycles = cycles.where((c) => c.cycleType == PomodoroCycleType.work).toList();
    final avgEfficiency = workCycles.isNotEmpty 
        ? workCycles.map((c) => c.actualDuration.inMilliseconds.toDouble() / c.plannedDuration.inMilliseconds.toDouble()).reduce((a, b) => a + b) / workCycles.length
        : 1.0;
    final processingSpeed = (avgEfficiency * 100).clamp(0.0, 150.0);
    
    // Memory retention by note type
    final memoryRetentionByType = <String, double>{};
    for (final noteType in PomodoroNoteType.values) {
      final typeNotes = notes.where((n) => n.noteType == noteType).toList();
      if (typeNotes.isNotEmpty) {
        // Calculate retention based on note frequency and timing distribution
        final retention = min(100.0, (typeNotes.length * 20).toDouble());
        memoryRetentionByType[noteType.name] = retention;
      }
    }
    
    // Cognitive profile analysis
    final cognitiveProfile = _analyzePomodoroCognitiveProfile(session, cycles, notes, focusScores);
    
    // Attention span based on focus score decline over time
    final attentionSpan = _calculatePomodoroAttentionSpan(cycles, focusScores);
    
    return CognitiveAnalysis(
      cognitiveLoadScore: cognitiveLoadScore,
      memoryRetentionByType: memoryRetentionByType,
      processingSpeed: processingSpeed,
      cognitiveStrengths: cognitiveProfile['strengths']!,
      cognitiveWeaknesses: cognitiveProfile['weaknesses']!,
      attentionSpan: attentionSpan,
    );
  }

  /// Generate AI-powered insights for Pomodoro sessions
  Future<Map<String, dynamic>> _generatePomodoroAIInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
    Course course,
    Module module,
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) async {
    try {
      print('ü§ñ [POMODORO AI INSIGHTS] Generating AI-powered recommendations...');
      
      // Create comprehensive data summary for AI
      final analyticsData = {
        'technique': 'pomodoro',
        'course': course.title,
        'module': module.title,
        'session_data': {
          'total_cycles': cycles.length,
          'completed_cycles': cycles.where((c) => c.isCompleted).length,
          'total_duration_minutes': session.totalDuration.inMinutes,
          'work_cycles': cycles.where((c) => c.cycleType == PomodoroCycleType.work).length,
          'break_cycles': cycles.where((c) => c.cycleType != PomodoroCycleType.work).length,
          'notes_taken': notes.length,
        },
        'focus_analysis': {
          'average_focus_score': cycles.where((c) => c.focusScore != null).isNotEmpty 
              ? cycles.where((c) => c.focusScore != null).map((c) => c.focusScore!).reduce((a, b) => a + b) / cycles.where((c) => c.focusScore != null).length
              : 0.0,
          'focus_progression': patterns.learningVelocity,
          'pattern_type': patterns.patternType.name,
        },
        'performance': {
          'productivity_score': performance.accuracyByDifficulty,
          'completion_rate': performance.materialPerformance['Completion Rate'] ?? 0.0,
          'improvement': performance.improvementPercentage,
        },
        'behavior': {
          'persistence_score': behavior.persistenceScore,
          'engagement_level': behavior.engagementLevel,
          'break_adherence': behavior.hintEffectiveness,
          'common_challenges': behavior.commonErrorTypes,
        },
        'cognitive': {
          'cognitive_load': cognitive.cognitiveLoadScore,
          'processing_efficiency': cognitive.processingSpeed,
          'attention_span': cognitive.attentionSpan,
          'strengths': cognitive.cognitiveStrengths,
          'weaknesses': cognitive.cognitiveWeaknesses,
        },
        'notes_analysis': {
          'study_notes': notes.where((n) => n.noteType == PomodoroNoteType.studyNote).length,
          'reflections': notes.where((n) => n.noteType == PomodoroNoteType.reflection).length,
          'quiz_answers': notes.where((n) => n.noteType == PomodoroNoteType.quizAnswer).length,
        },
      };
      
      // Generate AI insights using the enhanced Gemini service
      final aiResults = await _aiService.generatePomodoroAnalyticsInsights(analyticsData);
      
      return aiResults;
      
    } catch (e) {
      print('‚ùå [POMODORO AI INSIGHTS] Error generating AI insights: $e');
      
      // Return fallback insights
      return _generateFallbackPomodoroInsights(performance, patterns, behavior, cognitive, session, cycles, notes);
    }
  }

  // Helper methods for Pomodoro analytics

  Map<String, double> _analyzePomodoroConceptMastery(List<PomodoroNote> notes) {
    final conceptMastery = <String, double>{};
    
    // Analyze note types as concept indicators
    for (final noteType in PomodoroNoteType.values) {
      final typeNotes = notes.where((n) => n.noteType == noteType).toList();
      if (typeNotes.isNotEmpty) {
        // Higher note count indicates better engagement with concept
        final mastery = min(100.0, (typeNotes.length * 15).toDouble());
        conceptMastery[noteType.displayName] = mastery;
      }
    }
    
    return conceptMastery;
  }

  double _calculateTrend(List<double> values) {
    if (values.length < 2) return 0.0;
    
    // Simple linear trend calculation
    double sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
    
    for (int i = 0; i < values.length; i++) {
      sumX += i;
      sumY += values[i];
      sumXY += i * values[i];
      sumXX += i * i;
    }
    
    final n = values.length;
    final slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    return slope;
  }

  Map<String, List<String>> _analyzePomodoroNotePatterns(List<PomodoroNote> notes) {
    // Identify strong areas (many notes) and weak areas (few notes)
    final notesByType = <PomodoroNoteType, List<PomodoroNote>>{};
    
    for (final note in notes) {
      notesByType[note.noteType] ??= [];
      notesByType[note.noteType]!.add(note);
    }
    
    final strong = <String>[];
    final weak = <String>[];
    
    for (final type in PomodoroNoteType.values) {
      final count = notesByType[type]?.length ?? 0;
      if (count >= 3) {
        strong.add(type.displayName);
      } else if (count == 0) {
        weak.add(type.displayName);
      }
    }
    
    return {'strong': strong, 'weak': weak};
  }

  Map<String, double> _calculatePomodoroRetentionRates(List<PomodoroCycle> cycles, List<PomodoroNote> notes) {
    final retentionRates = <String, double>{};
    
    // Calculate retention based on consistent focus scores
    final workCycles = cycles.where((c) => c.cycleType == PomodoroCycleType.work).toList();
    if (workCycles.isNotEmpty) {
      final focusScores = workCycles
          .where((c) => c.focusScore != null)
          .map((c) => c.focusScore!.toDouble())
          .toList();
      
      if (focusScores.isNotEmpty) {
        final avgFocus = focusScores.reduce((a, b) => a + b) / focusScores.length;
        retentionRates['Focus Consistency'] = avgFocus * 10;
      }
    }
    
    // Note-based retention
    final noteTypes = notes.map((n) => n.noteType).toSet();
    for (final type in noteTypes) {
      final typeNotes = notes.where((n) => n.noteType == type).length;
      retentionRates[type.displayName] = min(100.0, typeNotes * 20);
    }
    
    return retentionRates;
  }

  List<TimeBasedPattern> _analyzePomodoroTemporalPatterns(PomodoroSession session, List<PomodoroCycle> cycles) {
    final patterns = <TimeBasedPattern>[];
    
    // Analyze productivity by time periods
    if (cycles.isNotEmpty) {
      final earlyPerformance = cycles.take(cycles.length ~/ 2).toList();
      final latePerformance = cycles.skip(cycles.length ~/ 2).toList();
      
      final earlyFocus = _calculateAverageFocus(earlyPerformance);
      final lateFocus = _calculateAverageFocus(latePerformance);
      
      patterns.add(TimeBasedPattern(
        timeframe: 'early_session',
        performanceScore: earlyFocus * 10,
        pattern: earlyFocus > 6 ? 'high_early_focus' : 'low_early_focus',
        observations: ['Early session focus level: ${earlyFocus.toStringAsFixed(1)}/10'],
      ));
      
      patterns.add(TimeBasedPattern(
        timeframe: 'late_session',
        performanceScore: lateFocus * 10,
        pattern: lateFocus > earlyFocus ? 'improving_focus' : 'declining_focus',
        observations: ['Late session focus level: ${lateFocus.toStringAsFixed(1)}/10'],
      ));
    }
    
    return patterns;
  }

  Map<String, int> _analyzeNotePatterns(List<PomodoroNote> notes, List<PomodoroCycle> cycles) {
    return {
      'total_notes': notes.length,
      'study_notes': notes.where((n) => n.noteType == PomodoroNoteType.studyNote).length,
      'reflections': notes.where((n) => n.noteType == PomodoroNoteType.reflection).length,
      'quiz_answers': notes.where((n) => n.noteType == PomodoroNoteType.quizAnswer).length,
      'notes_per_cycle': cycles.isNotEmpty ? (notes.length / cycles.length).round() : 0,
    };
  }

  Map<String, List<String>> _analyzePomodoroCognitiveProfile(
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
    List<double> focusScores,
  ) {
    final strengths = <String>[];
    final weaknesses = <String>[];
    
    // Analyze focus consistency
    if (focusScores.isNotEmpty) {
      final avgFocus = focusScores.reduce((a, b) => a + b) / focusScores.length;
      final focusVariance = _calculateVariance(focusScores);
      
      if (avgFocus >= 7) {
        strengths.add('High average focus');
      } else if (avgFocus < 4) {
        weaknesses.add('Low average focus');
      }
      
      if (focusVariance < 2) {
        strengths.add('Consistent focus levels');
      } else if (focusVariance > 4) {
        weaknesses.add('Inconsistent focus levels');
      }
    }
    
    // Analyze cycle completion
    final completionRate = cycles.isNotEmpty 
        ? cycles.where((c) => c.isCompleted).length / cycles.length
        : 0.0;
    
    if (completionRate > 0.8) {
      strengths.add('Excellent cycle completion');
    } else if (completionRate < 0.5) {
      weaknesses.add('Difficulty completing cycles');
    }
    
    // Analyze note-taking engagement
    if (notes.length > cycles.length) {
      strengths.add('Active note-taking');
    } else if (notes.isEmpty && cycles.isNotEmpty) {
      weaknesses.add('Limited note-taking');
    }
    
    return {
      'strengths': strengths.isEmpty ? ['Completed study session'] : strengths,
      'weaknesses': weaknesses.isEmpty ? ['No significant weaknesses identified'] : weaknesses,
    };
  }

  double _calculatePomodoroAttentionSpan(List<PomodoroCycle> cycles, List<double> focusScores) {
    if (focusScores.length < 3) return 100.0;
    
    // Check if focus declines over time
    final firstThird = focusScores.take(focusScores.length ~/ 3).toList();
    final lastThird = focusScores.skip((focusScores.length * 2) ~/ 3).toList();
    
    final earlyAvg = firstThird.reduce((a, b) => a + b) / firstThird.length;
    final lateAvg = lastThird.reduce((a, b) => a + b) / lastThird.length;
    
    // Good attention span if focus is maintained or improved
    final attentionScore = lateAvg >= earlyAvg ? 100.0 : ((lateAvg / earlyAvg) * 100);
    
    return attentionScore.clamp(0.0, 100.0);
  }

  double _calculateAverageFocus(List<PomodoroCycle> cycles) {
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!)
        .toList();
    
    return focusScores.isNotEmpty 
        ? focusScores.reduce((a, b) => a + b) / focusScores.length
        : 5.0;
  }

  /// Generate fallback insights for Pomodoro when AI generation fails
  Map<String, dynamic> _generateFallbackPomodoroInsights(
    PerformanceMetrics performance,
    LearningPatterns patterns,
    BehaviorAnalysis behavior,
    CognitiveAnalysis cognitive,
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    final avgFocus = performance.materialPerformance['Focus Score'] ?? 50.0;
    final completionRate = performance.materialPerformance['Completion Rate'] ?? 0.0;
    
    final recommendations = <PersonalizedRecommendation>[
      PersonalizedRecommendation(
        id: 'pomodoro_fallback_rec_1',
        type: RecommendationType.studyTiming,
        title: 'Optimize Pomodoro Settings',
        description: 'Based on your session performance, consider adjusting your Pomodoro cycle length.',
        actionableAdvice: completionRate > 80 
            ? 'Great job completing most cycles! Consider extending work periods slightly for deeper focus.'
            : avgFocus < 50
                ? 'Try shorter work periods (15-20 minutes) to build focus gradually.'
                : 'Maintain current cycle length but focus on minimizing distractions.',
        priority: 1,
        confidenceScore: 0.8,
        reasons: ['Focus score analysis', 'Completion rate patterns'],
      ),
      PersonalizedRecommendation(
        id: 'pomodoro_fallback_rec_2',
        type: RecommendationType.studyMethods,
        title: 'Enhance Note-Taking',
        description: 'Improve learning retention through structured note-taking.',
        actionableAdvice: notes.isEmpty 
            ? 'Take at least one note per work cycle to enhance retention.'
            : notes.length < cycles.length 
                ? 'Increase note-taking frequency for better learning outcomes.'
                : 'Excellent note-taking! Consider organizing notes by topic.',
        priority: 2,
        confidenceScore: 0.7,
        reasons: ['Note-taking analysis', 'Learning effectiveness'],
      ),
    ];
    
    final insights = <AnalyticsInsight>[
      AnalyticsInsight(
        id: 'pomodoro_fallback_insight_1',
        category: InsightCategory.performance,
        title: 'Focus Performance',
        insight: 'Your average focus score was ${avgFocus.toStringAsFixed(1)}/10 across ${cycles.length} cycles.',
        significance: 0.9,
        supportingData: [
          'Completed cycles: ${cycles.where((c) => c.isCompleted).length}/${cycles.length}',
          'Notes taken: ${notes.length}',
          'Total study time: ${session.totalDuration.inMinutes} minutes'
        ],
      ),
      AnalyticsInsight(
        id: 'pomodoro_fallback_insight_2',
        category: InsightCategory.behavior,
        title: 'Study Behavior Patterns',
        insight: 'You maintained a ${behavior.engagementLevel.toStringAsFixed(1)}% engagement level throughout the session.',
        significance: 0.7,
        supportingData: [
          'Persistence score: ${behavior.persistenceScore.toStringAsFixed(1)}%',
          'Break adherence: ${(behavior.hintEffectiveness * 100).toStringAsFixed(1)}%'
        ],
      ),
    ];
    
    final studyPlan = StudyPlan(
      id: 'pomodoro_fallback_plan',
      activities: [
        StudyActivity(
          type: 'focused_review',
          description: avgFocus < 50 
              ? 'Practice focus-building exercises before next session'
              : 'Continue with current focus strategies',
          duration: const Duration(minutes: 25),
          priority: 1,
          materials: patterns.weakConcepts.isEmpty ? ['Review session notes'] : patterns.weakConcepts,
        ),
        if (notes.isEmpty || notes.length < cycles.length)
          StudyActivity(
            type: 'note_taking',
            description: 'Implement structured note-taking during work cycles',
            duration: const Duration(minutes: 5),
            priority: 2,
            materials: ['Note-taking templates', 'Review prompts'],
          ),
      ],
      estimatedDuration: Duration(minutes: notes.isEmpty ? 30 : 25),
      focusAreas: {
        'focus_improvement': avgFocus < 50 ? 'Priority' : 'Maintain',
        'note_taking': notes.length < cycles.length ? 'Increase' : 'Continue',
        'cycle_completion': completionRate < 80 ? 'Improve' : 'Maintain',
      },
      objectives: [
        if (avgFocus < 50) 'Improve focus consistency',
        if (completionRate < 80) 'Increase cycle completion rate',
        if (notes.isEmpty) 'Begin regular note-taking practice',
        'Maintain productive study habits',
      ],
    );
    
    return {
      'recommendations': recommendations,
      'insights': insights,
      'studyPlan': studyPlan,
    };
  }

  /// Generate fallback Pomodoro analytics when full analysis fails
  StudySessionAnalytics _generateFallbackPomodoroAnalytics(
    String sessionId,
    String userId,
    String moduleId,
    PomodoroSession session,
    List<PomodoroCycle> cycles,
    List<PomodoroNote> notes,
  ) {
    // Basic calculations
    final focusScores = cycles
        .where((c) => c.focusScore != null)
        .map((c) => c.focusScore!)
        .toList();
    
    final avgFocusScore = focusScores.isNotEmpty 
        ? focusScores.reduce((a, b) => a + b) / focusScores.length 
        : 5.0;
    
    final completionRate = cycles.isNotEmpty 
        ? (cycles.where((c) => c.isCompleted).length / cycles.length) * 100
        : 0.0;
    
    final basicPerformance = PerformanceMetrics(
      preStudyAccuracy: avgFocusScore * 10,
      postStudyAccuracy: avgFocusScore * 10,
      improvementPercentage: 0.0,
      averageResponseTime: session.totalDuration.inMinutes / max(1, cycles.length).toDouble(),
      accuracyByDifficulty: (avgFocusScore * 10 + completionRate) / 2,
      materialPerformance: {'Focus Score': avgFocusScore * 10, 'Completion Rate': completionRate},
      conceptMastery: {},
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(avgFocusScore * 10),
    );
    
    return StudySessionAnalytics(
      id: '', // Database will generate UUID
      sessionId: sessionId,
      userId: userId,
      moduleId: moduleId,
      analyzedAt: DateTime.now(),
      performanceMetrics: basicPerformance,
      learningPatterns: LearningPatterns(
        patternType: LearningPatternType.steadyProgression,
        learningVelocity: 0.0,
        strongConcepts: [],
        weakConcepts: [],
        retentionRates: {},
        temporalPatterns: [],
      ),
      behaviorAnalysis: BehaviorAnalysis(
        totalStudyTime: session.totalDuration,
        hintUsageCount: notes.where((n) => n.noteType == PomodoroNoteType.reflection).length,
        hintEffectiveness: 0.75,
        commonErrorTypes: [],
        questionAttemptPatterns: {},
        persistenceScore: completionRate,
        engagementLevel: avgFocusScore * 10,
      ),
      cognitiveAnalysis: CognitiveAnalysis(
        cognitiveLoadScore: 50.0,
        memoryRetentionByType: {},
        processingSpeed: completionRate,
        cognitiveStrengths: [],
        cognitiveWeaknesses: [],
        attentionSpan: avgFocusScore * 10,
      ),
      recommendations: [],
      insights: [],
      suggestedStudyPlan: StudyPlan(
        id: 'pomodoro_fallback_plan',
        activities: [],
        estimatedDuration: const Duration(minutes: 25),
        focusAreas: {},
        objectives: [],
      ),
    );
  }

  /// Generate fallback analytics when full analysis fails
  StudySessionAnalytics _generateFallbackAnalytics(
    String sessionId,
    String userId,
    String moduleId,
    List<ActiveRecallFlashcard> flashcards,
    List<ActiveRecallAttempt> attempts,
  ) {
    // Basic calculations
    final preStudyAttempts = attempts.where((a) => a.isPreStudy).toList();
    final postStudyAttempts = attempts.where((a) => !a.isPreStudy).toList();
    
    final preAccuracy = preStudyAttempts.isNotEmpty ? (preStudyAttempts.where((a) => a.isCorrect).length / preStudyAttempts.length) * 100 : 0.0;
    final postAccuracy = postStudyAttempts.isNotEmpty ? (postStudyAttempts.where((a) => a.isCorrect).length / postStudyAttempts.length) * 100 : 0.0;
    final improvementPercentage = postAccuracy - preAccuracy;
    final averageResponseTime = attempts.isNotEmpty ? attempts.map((a) => a.responseTimeSeconds).reduce((a, b) => a + b) / attempts.length : 0.0;
    
    final basicPerformance = PerformanceMetrics(
      preStudyAccuracy: preAccuracy,
      postStudyAccuracy: postAccuracy,
      improvementPercentage: improvementPercentage,
      averageResponseTime: averageResponseTime,
      accuracyByDifficulty: 0.0,
      materialPerformance: {},
      conceptMastery: {},
      overallLevel: AnalyticsCalculator.determinePerformanceLevel(postAccuracy),
    );
    
    return StudySessionAnalytics(
      id: '', // Database will generate UUID
      sessionId: sessionId,
      userId: userId,
      moduleId: moduleId,
      analyzedAt: DateTime.now(),
      performanceMetrics: basicPerformance,
      learningPatterns: LearningPatterns(
        patternType: LearningPatternType.steadyProgression,
        learningVelocity: 0.0,
        strongConcepts: [],
        weakConcepts: [],
        retentionRates: {},
        temporalPatterns: [],
      ),
      behaviorAnalysis: BehaviorAnalysis(
        totalStudyTime: Duration(seconds: attempts.fold<int>(0, (sum, a) => sum + a.responseTimeSeconds)),
        hintUsageCount: 0,
        hintEffectiveness: 0.0,
        commonErrorTypes: [],
        questionAttemptPatterns: {},
        persistenceScore: 75.0,
        engagementLevel: 75.0,
      ),
      cognitiveAnalysis: CognitiveAnalysis(
        cognitiveLoadScore: 50.0,
        memoryRetentionByType: {},
        processingSpeed: 50.0,
        cognitiveStrengths: [],
        cognitiveWeaknesses: [],
        attentionSpan: 75.0,
      ),
      recommendations: [],
      insights: [],
      suggestedStudyPlan: StudyPlan(
        id: 'fallback_plan',
        activities: [],
        estimatedDuration: const Duration(minutes: 30),
        focusAreas: {},
        objectives: [],
      ),
    );
  }
}